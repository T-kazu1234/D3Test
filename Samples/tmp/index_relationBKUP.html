<!DOCTYPE html>
<html lang='ja'>
  <head>
    <meta charset='utf-8'>
    <title>D3 Relation Sample TypeS</title>

    <!-- Script -->
    <script type='text/javascript' src='./lib/js/jquery/jquery-3.1.1.min.js'></script>　　　
    <script src='https://d3js.org/d3.v4.min.js'></script>
    <script src='https://d3js.org/d3-scale-chromatic.v1.min.js'></script> <!--色見本を使えるように-->
    <!-- CSS -->
    <link rel='stylesheet' href='./lib/css/Relation.css' type='text/css'>

  </head>

  <body style='height:100%;'>
    <div id='title'>
      <div>相関図サンプル　d3 Version 4.4.0.</div>
    </div>

    <!--描画領域 -->
    <div class='vis' style='background-color:#9c9c9c;width:100%;'></div>

    <script>
        //描画領域のサイズ指定
      var width = $('.vis').width(),  //JQuery
          height = 800,
          RectX = 40,
          RectY = 30,
          r = 20,
        //Drag&Zoom用
          transform = d3.zoomIdentity,
        //色
          color = d3.scaleOrdinal(d3.schemeCategory20b),        //色見本は　https://github.com/d3/d3-scale/blob/master/README.md#schemeCategory20
          LineCol = d3.scaleSequential(d3.interpolateBlues);    //色見本は　https://github.com/d3/d3-scale-chromatic


    //vis領域の定義(Zoomに使用するベースのSVG領域)
      var vis = d3.select('.vis')
          .append('svg')
          .attr('width', width)
          .attr('height', height)
          .call(d3.zoom()
                .scaleExtent([1/4,4])
                .on('zoom', svgZoomed));

    //svg領域の定義（モノを配置するSVG領域）
      var svg = vis.append('g')
          .call(d3.drag()
              .on('drag',svgDragged))

      var simulation = d3.forceSimulation()
            .velocityDecay(0.3)                                                     //摩擦
          .force('charge', d3.forceManyBody())                                      //
          .force('link', d3.forceLink().id(function(d) { return d.id; }), 0.1)      //
          .force('colllision',d3.forceCollide(RectX))                                  //nodeの衝突半径：Nodeの最大値と同じ
          .force('positioningX',d3.forceX())
          .force('positioningY',d3.forceY())                    //nodeの衝突半径：Nodeの最大値と同じ
          .force('center', d3.forceCenter(width / 2, height / 2));                  //重力の中心

    //jsonファイルの読込
      d3.json('./miserables.json', function(error, graph) {                     //JSONファイルから設定
        if (error) throw error;

      //Linkの定義
        var link = svg.append('g')
              .attr('class', 'links')
            .selectAll('g')
            .data(graph.links)
            .enter()
            .append('line')
            .attr('stroke', function(d) { return LineCol(0.2+d.value/50); })             //線の色
            .attr('stroke-width', function(d) { return d.value +1; })　           //線の太さ
            .style('pointer-events', 'stroke')
            .on('mouseover', function(){d3.select(this).style('stroke', 'red');})
            .on('mouseout', function(){d3.select(this).style('stroke', function(d) {return LineCol(0.2+d.value/50)})})
            .call(d3.drag()　              //無いとエラーになる。。
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))


      // nodeの定義
        var node = svg.append('g')
              .attr('class', 'nodes')
            .selectAll('g')
            .data(graph.nodes)
            .enter()
            .append('g')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))

    // node circleの定義
        node.append('circle')
          .attr('r', r)
          .attr('stroke', '#ccc')
          .attr('fill', function(d) { return color(d.group); })
          .attr('visibility',function(d){
                var res = ChkRect(d);
                if (!res)
                  {return 'visible'}
                else
                  {return 'hidden'}
                })
          .style('stroke-width', '2')
          .on('mouseover', function(){d3.select(this).style('fill', 'red')})
          .on('mouseout', function(){d3.select(this).style('fill', function(d) { return color(d.group); })})

    // node Rectの定義
        node.append('rect')
          .attr('width', RectX)
          .attr('height', RectY)
          .attr('stroke', '#ccc')
          .attr('fill', function(d) { return color(d.group); })
          .attr('x',function(d){
                var res = ChkRect(d);
                if (res)
                  {return -(RectX/2)}
               })
          .attr('y',function(d){
                var res = ChkRect(d);
                if (res)
                  {return -(RectY/2)}
               })
          .attr('visibility',function(d){
                var res = ChkRect(d);
                if (res)
                  {return 'visible'}
                else
                  {return 'hidden'}
                })
          .style('stroke-width', '2')
          .on('mouseover', function(){d3.select(this).style('fill', 'red')})
          .on('mouseout', function(){d3.select(this).style('fill', function(d) { return color(d.group); })})

      //node textの定義
        node.append('text')
            .attr('text-anchor', 'middle')
            .attr('fill', 'black')
            .style('pointer-events', 'none')
            .attr('font-size', function(d) {return '10px'; }  )
          //  .attr('font-weight', function(d) { return 'bold'; }  )
            .text(function(d) { return d.id; })

        simulation
            .nodes(graph.nodes)
            .on('tick', ticked);

        simulation.force('link')
            .distance(200)             //Link長
            .links(graph.links);

        simulation.force('charge')     //forceManyBody
          .strength(function(d) {return -300})              //node間の力

        simulation.force('positioningX')
          .strength(0.04)

        simulation.force('positioningY')
          .strength(0.04)

        function ticked() {
          link
              .attr('x1', function(d) { return d.source.x; })
              .attr('y1', function(d) { return d.source.y; })
              .attr('x2', function(d) { return d.target.x; })
              .attr('y2', function(d) { return d.target.y; });

          node
              .attr('cx', function(d) { return d.x; })
              .attr('cy', function(d) { return d.y; })
              .attr('transform', function(d) {return 'translate(' + d.x + ',' + d.y + ')'})
        }
      });

    //rect判定
      function ChkRect(d){
          return (d.group <= 3)
      }

      function svgZoomed() {
          svg.attr('transform', d3.event.transform);
      }

      function svgDragged(d) {
          d3.select(this).attr('cx', d.x = d3.event.x).attr('cy', d.y = d3.event.y);
            };

      function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
      }

      function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

    </script>
  </body>
</html>
